/*! Minimal Chart.js-compatible renderer for size dashboard.
 * Supports type: 'bar' (existing comparison chart) and 'line' (history chart).
 */
(function (global) {
    'use strict';

    var DEFAULT_COLORS = ['#2563eb', '#94a3b8', '#16a34a', '#f97316'];

    function Chart(ctx, config) {
        if (!(this instanceof Chart)) return new Chart(ctx, config);
        this.ctx = ctx && ctx.canvas ? ctx.canvas.getContext('2d') : ctx;
        this.config = config || {};
        this._meta = [];
        this._activeElements = [];
        var self = this;
        this.tooltip = {
            _elements: [],
            setActiveElements: function (elements) {
                self.setActiveElements(elements);
            },
        };
        this._render();
    }

    Chart.prototype.getDatasetMeta = function (index) {
        return this._meta[index] || { data: [] };
    };

    Chart.prototype.setActiveElements = function (elements) {
        this._activeElements = Array.isArray(elements) ? elements : [];
        this.tooltip._elements = this._activeElements;
        this._render();
    };

    Chart.prototype.update = function (newConfig) {
        if (newConfig) {
            this.config = newConfig;
        }
        this._render();
    };

    Chart.prototype.destroy = function () {
        if (this.ctx) {
            this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
        }
        this._meta = [];
        this._activeElements = [];
    };

    Chart.prototype._computeYMax = function (datasets) {
        var maxValue = 0;
        datasets.forEach(function (dataset) {
            (dataset.data || []).forEach(function (value) {
                var numeric = Number(value);
                if (Number.isFinite(numeric)) {
                    maxValue = Math.max(maxValue, numeric);
                }
            });
        });
        if (maxValue === 0) {
            return 1;
        }
        var exponent = Math.floor(Math.log10(maxValue));
        var step = Math.pow(10, exponent);
        return Math.ceil(maxValue / step) * step;
    };

    Chart.prototype._drawAxes = function (ctx, padding, width, height, chartHeight, yMax) {
        ctx.strokeStyle = '#cbd5f5';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, height - padding);
        ctx.lineTo(width - padding, height - padding);
        ctx.stroke();

        ctx.fillStyle = '#475569';
        ctx.font = '12px sans-serif';
        var numTicks = 5;
        for (var i = 0; i <= numTicks; i++) {
            var value = (yMax / numTicks) * i;
            var y = height - padding - (chartHeight * (value / yMax));
            ctx.strokeStyle = '#e2e8f0';
            ctx.beginPath();
            ctx.moveTo(padding, y);
            ctx.lineTo(width - padding, y);
            ctx.stroke();
            ctx.fillText(formatNumber(value), 10, y + 4);
        }
    };

    Chart.prototype._renderBar = function (ctx, options) {
        var width = options.width;
        var height = options.height;
        var padding = options.padding;
        var chartWidth = options.chartWidth;
        var chartHeight = options.chartHeight;
        var labels = options.labels;
        var datasets = options.datasets;
        var yMax = options.yMax;

        var barGroups = labels.length;
        var barsPerGroup = datasets.length;
        var groupWidth = chartWidth / Math.max(barGroups, 1);
        var barWidth = Math.max((groupWidth * 0.7) / Math.max(barsPerGroup, 1), 8);

        this._meta = [];

        labels.forEach(function (label, groupIndex) {
            var groupX = padding + groupWidth * groupIndex + groupWidth / 2;
            ctx.fillStyle = '#1f2937';
            ctx.save();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(label, groupX, height - padding + 8);
            ctx.restore();

            datasets.forEach(function (dataset, datasetIndex) {
                var meta = (this._meta[datasetIndex] = this._meta[datasetIndex] || { data: [] });
                var value = Number(dataset.data[groupIndex] || 0);
                value = Number.isFinite(value) ? value : 0;
                var barHeight = chartHeight * (value / yMax);
                var barX = groupX - (barWidth * barsPerGroup) / 2 + datasetIndex * barWidth + datasetIndex * 4;
                var barY = height - padding - barHeight;
                ctx.fillStyle = dataset.backgroundColor || DEFAULT_COLORS[datasetIndex % DEFAULT_COLORS.length];
                ctx.fillRect(barX, barY, barWidth, barHeight);
                meta.data[groupIndex] = {
                    x: barX + barWidth / 2,
                    y: barY,
                    width: barWidth,
                    height: barHeight,
                    value: value,
                };
            }, this);
        }, this);
    };

    Chart.prototype._renderLine = function (ctx, options) {
        var width = options.width;
        var height = options.height;
        var padding = options.padding;
        var chartWidth = options.chartWidth;
        var chartHeight = options.chartHeight;
        var labels = options.labels;
        var datasets = options.datasets;
        var yMax = options.yMax;

        this._meta = [];

        var step = labels.length > 1 ? chartWidth / (labels.length - 1) : 0;

        datasets.forEach(function (dataset, datasetIndex) {
            var color = dataset.borderColor || dataset.backgroundColor || DEFAULT_COLORS[datasetIndex % DEFAULT_COLORS.length];
            var meta = { data: [] };
            var points = [];

            ctx.strokeStyle = color;
            ctx.lineWidth = dataset.borderWidth || 2;
            ctx.beginPath();
            (dataset.data || []).forEach(function (value, index) {
                var numeric = Number(value);
                numeric = Number.isFinite(numeric) ? numeric : 0;
                var x = padding + (labels.length > 1 ? step * index : chartWidth / 2);
                var y = height - padding - (chartHeight * (numeric / yMax));
                points.push({ x: x, y: y, value: numeric });
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                meta.data[index] = { x: x, y: y, value: numeric };
            });
            ctx.stroke();

            if (dataset.fill && points.length) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                points.forEach(function (point) {
                    ctx.lineTo(point.x, point.y);
                });
                ctx.lineTo(points[points.length - 1].x, height - padding);
                ctx.lineTo(points[0].x, height - padding);
                ctx.closePath();
                ctx.globalAlpha = 0.12;
                ctx.fillStyle = color;
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.restore();
            }

            ctx.fillStyle = dataset.pointBackgroundColor || color;
            var pointRadius = dataset.pointRadius || 3;
            points.forEach(function (point) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, pointRadius, 0, Math.PI * 2);
                ctx.fill();
            });

            this._meta[datasetIndex] = meta;
        }, this);
    };

    Chart.prototype._drawActiveElements = function (ctx) {
        if (!this._activeElements || !this._activeElements.length) {
            return;
        }
        var self = this;
        this._activeElements.forEach(function (element) {
            var meta = self._meta[element.datasetIndex];
            if (!meta) return;
            var point = meta.data[element.index];
            if (!point) return;
            ctx.save();
            ctx.strokeStyle = '#1f2937';
            ctx.fillStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        });
    };

    Chart.prototype._render = function () {
        var ctx = this.ctx;
        if (!ctx) {
            console.error('chart.min.js: missing canvas context');
            return;
        }

        var config = this.config || {};
        var type = config.type || 'bar';
        if (type !== 'bar' && type !== 'line') {
            console.warn('chart.min.js: type="' + type + '" is not fully supported, falling back to bar rendering.');
        }
        var data = config.data || {};
        var labels = data.labels || [];
        var datasets = data.datasets || [];

        ctx.save();
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        if (!labels.length || !datasets.length) {
            ctx.fillStyle = '#6b7280';
            ctx.font = '16px sans-serif';
            ctx.fillText('No data available', 20, 40);
            ctx.restore();
            this._meta = [];
            return;
        }

        var padding = 60;
        var width = ctx.canvas.width;
        var height = ctx.canvas.height;
        var chartWidth = Math.max(width - padding * 2, 1);
        var chartHeight = Math.max(height - padding * 2, 1);

        var yMax = this._computeYMax(datasets);
        this._drawAxes(ctx, padding, width, height, chartHeight, yMax);

        if (type === 'line') {
            this._renderLine(ctx, {
                width: width,
                height: height,
                padding: padding,
                chartWidth: chartWidth,
                chartHeight: chartHeight,
                labels: labels,
                datasets: datasets,
                yMax: yMax,
            });
        } else {
            this._renderBar(ctx, {
                width: width,
                height: height,
                padding: padding,
                chartWidth: chartWidth,
                chartHeight: chartHeight,
                labels: labels,
                datasets: datasets,
                yMax: yMax,
            });
        }

        this._drawActiveElements(ctx);
        ctx.restore();
    };

    function formatNumber(value) {
        if (value >= 1e9) return (value / 1e9).toFixed(1) + 'B';
        if (value >= 1e6) return (value / 1e6).toFixed(1) + 'M';
        if (value >= 1e3) return (value / 1e3).toFixed(1) + 'K';
        return String(Math.round(value));
    }

    global.Chart = Chart;
})(typeof window !== 'undefined' ? window : this);
